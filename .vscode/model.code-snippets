{
  "Model Class": {
    "prefix": "@model",
    "body": [
      "import type { DatabaseResult } from '@/types/database';",
      "import type { BuildModelResult, Model, ModelBuilder, ModelBuilderInternal, ModelBuilderType, ModelGenerator, ModelInstances, ModelMetadata, ModelMode, ModelNormalizer, ModelRawData4build, ModelResolver, ModelSchemaRawOf, ModelUnwrappedInstances__DO_NOT_EXPOSE, ModeWithResolved } from '@/types/model';",
      "import type { ArrayElem, Brand, Nullable, Override } from '@/types/utils';",
      "import type {",
      "  Prisma,",
      "  PrismaClient,",
      "  ${1:ModelName} as SchemaRaw,",
      "} from '@prisma/client';",
      "import { Database } from '@/services/database.server';",
      "import { buildRawData, includeKeys2select, matchWithDefault, matchWithResolved, separateRawData } from '@/utils/model';",
      "import { err, ok } from 'neverthrow';",
      "import { match } from 'ts-pattern';",
      "import { z } from 'zod';",
      "",
      "/// Metadata ///",
      "",
      "const metadata = {",
      "  displayName: '${0}',",
      "  modelName: '${2:modelName}',",
      "  primaryKeyName: '${3:primaryKey}',",
      "} as const satisfies ModelMetadata<'${2:modelName}'>;",
      "",
      "/// Custom Types ///",
      "",
      "",
      "",
      "/// Model Types ///",
      "",
      "type Schema = Override<",
      "  SchemaRaw,",
      "  {",
      "  }",
      ">;",
      "",
      "type IncludeKey = keyof Prisma.${1:ModelName}Include;",
      "const includeKeys = [] as const satisfies IncludeKey[];",
      "",
      "interface SchemaResolvedRaw {",
      "}",
      "",
      "interface SchemaResolved {",
      "}",
      "",
      "/// ModelTypes ///",
      "",
      "type ModelGen = ModelGenerator<typeof metadata, SchemaRaw, Schema, SchemaResolvedRaw, SchemaResolved>;",
      "type ThisModelImpl<M extends ModelMode = 'DEFAULT'> = Model<M, ModelGen>;",
      "type ThisModel<M extends ModelMode = 'DEFAULT'> = $${1:ModelName}<M>;",
      "interface ThisModelVariants {",
      "  DEFAULT: ThisModel;",
      "  WITH_RESOLVED: ThisModel<'WITH_RESOLVED'>;",
      "}",
      "type RawData = ModelRawData4build<ThisModel>;",
      "",
      "/// Normalizer ///",
      "",
      "const normalizer = ((client, builder) => ({",
      "  schema: (__raw) => ({",
      "  }),",
      "  schemaResolved: (__rawResolved) => {",
      "    const { models } = new Database(client);",
      "    const { MemberAsPayer, MemberAsReceiver, MemberAsApprover } = __rawResolved;",
      "  },",
      ")) satisfies ModelNormalizer<ThisModel>;",
      "",
      "/// Model ///",
      "",
      "export class $${1:ModelName}<Mode extends ModelMode = 'DEFAULT'> implements ThisModelImpl<Mode> {",
      "  private dbError = Database.dbErrorWith(metadata);",
      "  private client;",
      "  public declare __struct: ThisModelImpl<Mode>;",
      "  public declare __variants: ThisModelVariants;",
      "",
      "  public __raw: SchemaRaw;",
      "  public data: Schema;",
      "  public __rawResolved: ModeWithResolved<Mode, SchemaResolvedRaw>;",
      "  public dataResolved: ModeWithResolved<Mode, SchemaResolved>;",
      "",
      "  private constructor(",
      "    public __prisma: PrismaClient,",
      "    { __raw, __rawResolved }: RawData,",
      "    private builder: ModelBuilderType,",
      "  ) {",
      "    const n = normalizer(__prisma, this.builder);",
      "",
      "    this.__raw = __raw;",
      "    this.data = n.schema(__raw);",
      "    const { rawResolved, dataResolved } = matchWithResolved<Mode, SchemaResolvedRaw, SchemaResolved>(__rawResolved, n.schemaResolved);",
      "    this.__rawResolved = rawResolved;",
      "    this.dataResolved = dataResolved;",
      "    this.client = __prisma;",
      "  }",
      "",
      "  public static with(client: PrismaClient): ModelBuilder<ThisModel> {",
      "    const __toUnwrappedInstances = ((rawData, builder) => ({",
      "      default: new $${1:ModelName}(client, rawData, builder),",
      "      withResolved: new $${1:ModelName}<'WITH_RESOLVED'>(client, rawData, builder),",
      "    })) satisfies ModelUnwrappedInstances__DO_NOT_EXPOSE<ThisModel>;",
      "",
      "    const toInstances = ((rawData, builder) => match(builder)",
      "      .with({ type: 'ANONYMOUS' }, () => err({ type: 'PERMISSION_DENIED', detail: { builder: {} } } as const))",
      "      .with({ type: 'SELF' }, () => ok(__toUnwrappedInstances(rawData, builder)))",
      "      .with({ type: 'MEMBER' }, () => ok(__toUnwrappedInstances(rawData, builder)))",
      "      .exhaustive()",
      "    ) satisfies ModelInstances<ThisModel>;",
      "",
      "    const __build = {",
      "      __with: toInstances,",
      "      by: (rawData, memberAsBuilder) => toInstances(rawData, { type: 'MEMBER', member: memberAsBuilder }),",
      "      bySelf: (rawData) => toInstances(rawData, { type: 'SELF' }),",
      "    } satisfies ModelBuilderInternal<ThisModel>;",
      "",
      "    return {",
      "      __build,",
      "      from: (id: never) => {",
      "        const rawData = Database.transformResult(",
      "          client.${2:modelName}.findUniqueOrThrow({",
      "            where: { id },",
      "          }),",
      "        )",
      "          .mapErr(Database.dbErrorWith(metadata).transform('from'))",
      "          .map(separateRawData<ThisModel, IncludeKey>(includeKeys).default);",
      "",
      "        return rawData.map(buildRawData(__build).default);",
      "      },",
      "      fromWithResolved: (id: never) => {",
      "        const rawData = Database.transformResult(",
      "          client.${2:modelName}.findUniqueOrThrow({",
      "            where: { id },",
      "            include: includeKeys2select(includeKeys),",
      "          }),",
      "        )",
      "          .mapErr(Database.dbErrorWith(metadata).transform('fromWithResolved'))",
      "          .map(separateRawData<ThisModel, IncludeKey>(includeKeys).withResolved);",
      "",
      "        return rawData.map(buildRawData(__build).withResolved);",
      "      },",
      "    };",
      "  }",
      "",
      "  public resolveRelation(): ModelResolver<Mode, ThisModel> {",
      "    return matchWithDefault(",
      "      this.__rawResolved,",
      "      () => $${1:ModelName}.with(this.client).fromWithResolved(this.data.id),",
      "    );",
      "  }",
      "",
      "  public update(_data: Partial<Schema>): DatabaseResult<ThisModel> {",
      "    throw new Error('Method not implemented.');",
      "  }",
      "",
      "  public delete(_operator: ThisModel): DatabaseResult<void> {",
      "    throw new Error('Method not implemented.');",
      "  }",
      "",
      "  public hoge() { }",
      "}",
      ""
    ],
    "description": ""
  }
}
